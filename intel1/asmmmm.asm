;Определите содержимое EDX (в шестнадцатеричном формате) после выполнения программы       

lea EBX,M ;копирование в EBX адреса на M

mov ECX,8 ; запись  8 в регистр ecx

xor EDX,EDX ;очистка регистра EDX (как это произошло: сравнили число с самим собой с помощью исключающего или, у которого вы помните таблицу истинности, короче сброшен в ноль)

LP:   mov EAX,[EBX+1]  ;Объявление метки LP, запись в регистр eax смещенное на один значение из регистра ebx

and EAX,0FEh ;побитово сравниваем с 0fe то что в EAX, результат записан в EAX

add EDX,EAX ; edx +eax; результат записан в edx

inc EBX ;инкремент ebx - переход к следующему числу

loop LP ;возврат к метке

M:   DB 1,2,3,4,5,6,7,8,10,11,12,13


; Как программа работает на человеческом языке:
; объявлены числа,записаны в M

; скопировали в ebx адрес M
; В ecx записали 8 - у нас будет 8 итераций
; очистили EDX - он будет равен нулю

; метка
; команда mov EAX,[EBX+1] 
; в eax записывается число 05 04 03 02h - почему именно столько? 
; регистр 32 битный, больше не влезло, почему не 04030201h -потому что [EBX+1] 

; логическое и
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
				; и   0000 0101 0000 0100 0000 0011 0000 0010
 ; получаем 2(0000 0000 0000 0000 0000 0000 0000 0010)
 ; в eax у нас теперь двойка хранится
; команда add EDX,EAX 
; записываем эту двойку в edx , и оно теперь имеет значение 2
; делаем инкремент и возвращаемся к метке

; команда mov EAX,[EBX+2] 
; в eax записывается число 06050403h
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
				; и   0000 0110 0000 0101 0000 0100 0000 0011(6050403h)
; получаем 2 (0000 0000 0000 0000 0000 0000 0000 0010)
; в eax записывается число 2
; команда add EDX,EAX 
; прибавляем эту двойку к edx, и оно теперь имеет значение 4
; делаем инкремент и возвращаемся к метке


; команда mov EAX,[EBX+3] 
; в eax записывается число 07060504h
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
				; и   0000 0111 0000 0110 0000 0101 0000 0100(07060504h)
; получаем 4 (0000 0000 0000 0000 0000 0000 0000 0100)
; в eax записывается число 4
; команда add EDX,EAX 
; прибавляем эту четверку к edx , и оно теперь имеет значение 8
; делаем инкремент и возвращаемся к метке



; команда mov EAX,[EBX+4] 
; в eax записывается число 08070605h
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
				; и   0000 1000 0000 0111 0000 0110 0000 0101(08070605h)
; получаем 4 (0000 0000 0000 0000 0000 0000 0000 0100)
; в eax записывается число 4
; команда add EDX,EAX 
; прибавляем эту четверку к edx , и оно теперь имеет значение 12
; делаем инкремент и возвращаемся к метке



; команда mov EAX,[EBX+5] 
; в eax записывается число 0a080706h(а. как вы помните,10)
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
				; и   0000 1001 0000 1000 0000 0111 0000 0110 (a080706h)
; получаем 6 (0000 0000 0000 0000 0000 0000 0000 0110)
; в eax записывается число 6
; команда add EDX,EAX 
; прибавляем эту шестерку к edx , и оно теперь имеет значение 18
; делаем инкремент и возвращаемся к метке

; команда mov EAX,[EBX+5] 
; в eax записывается число 0b0a0807h(а. как вы помните,10)
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
				; и   0000 1011 0000 1010 0000 1000 0000 0111 (0a080706h)
; получаем 6 (0000 0000 0000 0000 0000 0000 0000 0110)
; в eax записывается число 6
; команда add EDX,EAX 
; прибавляем эту шестерку к edx, и оно теперь имеет значение 24
; делаем инкремент и возвращаемся к метке


; команда mov EAX,[EBX+6] 
; в eax записывается число 0c0b0a08h
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
				; и   0000 1100 0000 1011 0000 1010 0000 1000  (0c0b0a08h)
; получаем 8 (0000 0000 0000 0000 0000 0000 0000 1000)
; в eax записывается число 8
; команда add EDX,EAX 
; записываем эту восьмерку в edx , и оно теперь имеет значение 32
; делаем инкремент и возвращаемся к метке 



; команда mov EAX,[EBX+7] 
; в eax записывается число 0d0c0b0ah
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
				; и   0000 1101 0000 1100 0000 1011 0000 1010  (0d0c0b0ah)
; получаем 10 (0000 0000 0000 0000 0000 0000 0000 1010)
; в eax записывается число 10
; команда add EDX,EAX 
; записываем эту десятку в edx , и оно теперь имеет значение 42
; делаем инкремент и возвращаемся к метке 


; на этом программа заканчивается, нас спрашивают про значение в edx, оно 42
; переводим в шестнадцатеричный формат - это будет 2a

