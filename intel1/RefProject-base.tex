\begin{sloppypar} % помогает в кириллическом документе выровнять текст по краям
\newpage % Так добавляется  новая страница
{\renewcommand\fcolorbox[4][]{\textcolor{cyan}{\strut#4}}
 \begin{minted} [
 % frame=lines,%линия сверху и снизу блока кода
% framesep=15mm, % отступ между линией и кодом
baselinestretch=1, %интервал междустрочный
% bgcolor=LightGray, %цвет фона
fontsize=\footnotesize, %размер шрифта
% linenos%нумерация строк
]{gas}
 ;Определите содержимое EDX (в шестнадцатеричном формате) после выполнения программы       

lea EBX,M ;копирование в EBX адреса на M

mov ECX,8 ; запись  8 в регистр ecx

xor EDX,EDX ;очистка регистра EDX (как это произошло: сравнили число с самим собой с помощью исключающего или, у которого вы помните таблицу истинности, короче сброшен в ноль)

LP:   mov EAX,[EBX+1]  ;Объявление метки LP, запись в регистр eax смещенное на один значение из регистра ebx

and EAX,0FEh ;побитово сравниваем с 0fe то что в EAX, результат записан в EAX

add EDX, EAX ; edx +eax; результат записан в edx

inc EBX ;инкремент ebx - переход к следующему числу

loop LP ;возврат к метке

M:   DB 1,2,3,4,5,6,7,8,10,11,12,13


; Как программа работает на человеческом языке:
; объявлены числа,записаны в M

; скопировали в ebx адрес M
; В ecx записали 8 - у нас будет 8 итераций
; очистили EDX - он будет равен нулю

; метка
; команда mov EAX,[EBX+1] 
; в eax записывается число 05 04 03 02h - почему именно столько? 
; регистр 32 битный, больше не влезло, почему не 04030201h -потому что [EBX+1] 

; логическое и
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
		; и   0000 0101 0000 0100 0000 0011 0000 0010(05040302h)
;получили 2 (0000 0000 0000 0000 0000 0000 0000 0010)
 ; в eax у нас теперь двойка хранится
; команда add EDX,EAX 
; записываем эту двойку в edx , и оно теперь имеет значение 2
; делаем инкремент и возвращаемся к метке

; команда mov EAX,[EBX+2] 
; в eax записывается число 06050403h
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
		; и   0000 0110 0000 0101 0000 0100 0000 0011(6050403h)
; получаем 2 (0000 0000 0000 0000 0000 0000 0000 0010)
; в eax записывается число 2
; команда add EDX,EAX 
; прибавляем эту двойку к edx, и оно теперь имеет значение 4
; делаем инкремент и возвращаемся к метке


; команда mov EAX,[EBX+3] 
; в eax записывается число 07060504h
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
		; и   0000 0111 0000 0110 0000 0101 0000 0100(07060504h)
; получаем 4 (0000 0000 0000 0000 0000 0000 0000 0100)
; в eax записывается число 4
; команда add EDX,EAX 
; прибавляем эту четверку к edx , и оно теперь имеет значение 8
; делаем инкремент и возвращаемся к метке



; команда mov EAX,[EBX+4] 
; в eax записывается число 08070605h
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
		; и   0000 1000 0000 0111 0000 0110 0000 0101(08070605h)
; получаем 4 (0000 0000 0000 0000 0000 0000 0000 0100)
; в eax записывается число 4
; команда add EDX,EAX 
; прибавляем эту четверку к edx , и оно теперь имеет значение 12
; делаем инкремент и возвращаемся к метке



; команда mov EAX,[EBX+5] 
; в eax записывается число 0a080706h(а. как вы помните,10)
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
		; и   0000 1001 0000 1000 0000 0111 0000 0110 (a080706h)
; получаем 6 (0000 0000 0000 0000 0000 0000 0000 0110)
; в eax записывается число 6
; команда add EDX,EAX 
; прибавляем эту шестерку к edx , и оно теперь имеет значение 18
; делаем инкремент и возвращаемся к метке

; команда mov EAX,[EBX+5] 
; в eax записывается число 0b0a0807h(а. как вы помните,10)
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
		; и   0000 1011 0000 1010 0000 1000 0000 0111 (0a080706h)
; получаем 6 (0000 0000 0000 0000 0000 0000 0000 0110)
; в eax записывается число 6
; команда add EDX,EAX 
; прибавляем эту шестерку к edx, и оно теперь имеет значение 24
; делаем инкремент и возвращаемся к метке


; команда mov EAX,[EBX+6] 
; в eax записывается число 0c0b0a08h
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
		; и   0000 1100 0000 1011 0000 1010 0000 1000  (0c0b0a08h)
; получаем 8 (0000 0000 0000 0000 0000 0000 0000 1000)
; в eax записывается число 8
; команда add EDX,EAX 
; записываем эту восьмерку в edx , и оно теперь имеет значение 32
; делаем инкремент и возвращаемся к метке 



; команда mov EAX,[EBX+7] 
; в eax записывается число 0d0c0b0ah
; команда and EAX,0FEh
; сравниваем 0000 0000 0000 0000 0000 0000 1111 1110(FEh) 
		; и   0000 1101 0000 1100 0000 1011 0000 1010  (0d0c0b0ah)
; получаем 10 (0000 0000 0000 0000 0000 0000 0000 1010)
; в eax записывается число 10
; команда add EDX,EAX 
; записываем эту десятку в edx , и оно теперь имеет значение 42
; делаем инкремент и возвращаемся к метке 


; на этом программа заканчивается, нас спрашивают про значение в edx, оно 42
; переводим в шестнадцатеричный формат - это будет 2a





;и вторая программа




MOV ECX,28 ;запись значения 28 в регистр ecx(это длина строки, которая string db)

CLD ;cброс флага направления (DF), установка в 0.
;при флаге DF=0 строки обрабатываются в сторону увеличения адресов

MOV AL,'p' ;запись значения 'p' в 8 битный регистр al(это искомый символ)

LEA EDI,STRING ;запись адреса строки в регистр edi

REPNE SCASB ;повторять операцию, пока флаг ZF не равен 0, это запуск поиска
;флаг zf равен нулю, если при выполнении арифметической или логической операции получается число, равное нулю, то есть ищем пока не найдем
;а сравнение вообще запускается командой scasb: она побайтово сравнивает байт в ЕDI c байтом в AL
STRING DB "Radioengineering department" ;директива db используется для .... а почитаете сами тут - https://www.cyberforum.ru/assembler/thread1005284-page14.html

; Таким образом, эта же программа на человеческом языке:

; установить значение счетчика на 28

; начать обрабатывать строку с начала строки

; искомый символ храним в AL и это 'p'

; строка для перебора это STRING, записали ее адрес в EDI
; запускаем цикл перебора до первого совпадения, сравниваем байт в EDI с байтом AL
; пока не найдем, цикл работает, и уменьшается значение счетчика ECX
; смотрим на Radioengineering department
; Radioengineering de - 19 символов, значит следующее p будет 20 итерацией, после которой цикл остановится
; ну и раз счетчик уменьшился на 20, то 28-20 = 8 пишем в ответ




\end{minted}
}

\end{sloppypar}
